<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="cahies of tn: blog"><title>Web アプリケーションフレームワーク - cahiers of tn</title><link type=text/css rel=stylesheet href=https://ambi.github.io/css/bulma.min.css><link type=text/css rel=stylesheet href=https://ambi.github.io/css/style.css></head><body><section class=container><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class="navbar-item title" href=https://ambi.github.io/>cahiers of tn</a></div><div class=navbar-menu><div class=navbar-end><a class=navbar-item href=/posts/>Posts</a><a class=navbar-item href=/tags/>Tags</a></div></nav></section><hr><div id=main><div class=container><div class=columns><article class="column box is-8 content"><h1>Web アプリケーションフレームワーク</h1><section class=mb-6><h1 id=introduction>Introduction</h1><p>Web アプリケーションフレームワークについて調べたことをまとめる。</p><p><a href=https://en.wikipedia.org/wiki/Web_framework>Wikipedia の記事</a> によれば：</p><blockquote><p>Web フレームワーク (WF) または Web アプリケーションフレームワーク (WAF) とは、Web サービス・Web リソース・Web API を含む Web アプリケーションの開発をサポートするように設計されたソフトウェアフレームワークである。（中略）例として、多くの Web フレームワークは、データベースアクセス・テンプレートフレームワーク・セッション管理のライブラリを提供しており、コードの再利用をしやすくしている。動的な Web サイトの開発を主なターゲットとしているが、静的な Web サイトにも適用できる。</p></blockquote><h1 id=history>History</h1><p>1989年、イギリスのコンピュータサイエンティスト Tim Berners-Lee は、欧州原子核研究機構 (CERN) で Robert Cailliau とともに World Widde Web &ndash; Web を作り上げた。この時代の Web はまだ、静的なページをハイパーリンクでつなげ合った集合でしかなく、動的なページはなかった。オーパーツ的な Web ページはどこかに存在したかもしれないが、知らない。</p><p>1993年、米国立スーパーコンピュータ応用研究所 (NCSA) が <a href=https://datatracker.ietf.org/doc/html/rfc3875>Common Gateway Interface (CGI)</a> を定義した。CGI という技術は、Web サーバが HTTP リクエストごとに CGI 用プログラムを起動・実行して、その出力によって動的に Web ページを生成する。しかし、HTTP リクエストごとに CGI 用プログラムが起動されるため、負荷が大きい。</p><p>1996年、CGI の問題に対応するために <a href=https://perl.apache.org/about/history.html><code>mod_perl</code> (1996)</a>、<a href=https://en.wikipedia.org/wiki/Jakarta_Server_Pages>Java Servlet (1996-1997)</a>、<a href=https://en.wikipedia.org/wiki/Active_Server_Pages>Active Server Pages (1996)</a> が出て来た。これらは HTTP リクエストを処理するプログラムがリクエストごとに起動されるのでなく、デーモン的にずっと起動している１つのプログラムが何度も HTTP リクエストを処理してくれる。また、<a href=https://en.wikipedia.org/wiki/PHP>PHP (1995)</a>、Active Server Pages、<a href=https://en.wikipedia.org/wiki/Jakarta_Server_Pages>JavaServer Pages (1999)</a> にあるような <a href=https://en.wikipedia.org/wiki/Template_processor>HTML テンプレート機能</a>も導入された。HTML テンプレート機能は、HTML ページのうち動的に変わりうる箇所だけスクリプト（プログラム）を埋め込んで書ける機能で、動的なページの生成には便利だった。</p><p>最初の Web アプリケーションフレームワークが何なのかというのは難しいが、ともあれ1995年前後に、Web アプリケーションフレームワークの最初期段階が同時多発的に生まれていった。NeXT の <a href=https://en.wikipedia.org/wiki/WebObjects>WebObjects (1996)</a> が、MVC パターンを GUI でなく Web アプリケーションに適用して世に広めたとも言われているが、当時の情報が少なくて分からない。</p><p>1999年、<a href=https://docs.oracle.com/javaee/1.2.1/api/>Java 2 Platform, Enterprise Edition (J2EE)</a> がリリースされた。これは Java で Web アプリケーションなどのエンタープライズアプリケーションを開発するための統合的な Java API である。ここには前述の Java Servlet や JavaServer Pages のほか、ビジネスロジックを定義するための <a href=https://en.wikipedia.org/wiki/Jakarta_Enterprise_Beans>Enterprise JavaBeans</a>も含んでいる。ほかにも RDB とのインタフェースとなる JDBC、メールを扱う <code>javax.mail</code> もある。ただ、高機能な RDB 処理ライブラリである <a href=https://en.wikipedia.org/wiki/Jakarta_Persistence>Java Persistence API (JPA)</a> は Java EE 5 (2006) になるまで待たなければならない。</p><p>後述する PofEAA (2002) のコードサンプルが当時の空気感を理解しやすい：</p><p><code>web.xml</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;servlet&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;servlet-name&gt;</span>artist<span style=color:#f92672>&lt;/servlet-name&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;servlet-class&gt;</span>actionController.ArtistController<span style=color:#f92672>&lt;/servlet-class&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/servlet&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;servlet-mapping&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;servlet-name&gt;</span>artist<span style=color:#f92672>&lt;/servlet-name&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;url-pattern&gt;</span>/artist<span style=color:#f92672>&lt;/url-pattern&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/servlet-mapping&gt;</span>
</span></span></code></pre></div><p>Java コード:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ActionServlet</span> <span style=color:#66d9ef>extends</span> HttpServlet <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>forward</span><span style=color:#f92672>(</span>String target<span style=color:#f92672>,</span> HttpServletRequest request<span style=color:#f92672>,</span> HttpServletResponse response<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> IOException<span style=color:#f92672>,</span> ServletException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    RequestDispatcher dispatcher <span style=color:#f92672>=</span> getServletContext<span style=color:#f92672>().</span><span style=color:#a6e22e>getRequestDispatcher</span><span style=color:#f92672>(</span>target<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    dispatcher<span style=color:#f92672>.</span><span style=color:#a6e22e>forward</span><span style=color:#f92672>(</span>request<span style=color:#f92672>,</span> response<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ArtistController</span> <span style=color:#66d9ef>extends</span> ActionServlet <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doGet</span><span style=color:#f92672>(</span>HttpServleRequest request<span style=color:#f92672>,</span> HttpServletResponse response<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> IOException<span style=color:#f92672>,</span> ServletException <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    Artist artist <span style=color:#f92672>=</span> Artist<span style=color:#f92672>.</span><span style=color:#a6e22e>findNamed</span><span style=color:#f92672>(</span>request<span style=color:#f92672>.</span><span style=color:#a6e22e>getParameter</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;name&#34;</span><span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>artist <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      forward<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/MissingArtistError.jsp&#34;</span><span style=color:#f92672>,</span> request<span style=color:#f92672>,</span> response<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      request<span style=color:#f92672>.</span><span style=color:#a6e22e>setAttribute</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;helper&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>new</span> ArtistHelper<span style=color:#f92672>(</span>artist<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>      forward<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;/artist.jsp&#34;</span><span style=color:#f92672>,</span> request<span style=color:#f92672>,</span> response<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>2002年、<a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/articles/ms973868(v=msdn.10)?redirectedfrom=MSDN">ASP.NET</a> がリリースされた。前述の Active Server Pages (ASP) 技術を .NET Framework 上で置き換えたもので、どうも ASP とは全く別物で、代わりに Web Forms という概念が導入されている。</p><p>同じく2002年、Martin Fowler らは技術書 <a href=https://martinfowler.com/books/eaa.html>&ldquo;Patterns of Enterprise Application Architecture&rdquo;</a> を出版した。タイトル通り、エンタープライズアプリケーションのアーキテクチャのパターンを記述しているが、これはそのまま Web アプリケーションのアーキテクチャのパターンだった。MVC、DTO、アクティブレコード、リポジトリ、ドメインモデル、サービスレイヤーなど、現代でも使われている様々なパターンがここでまとまって解説されている。</p><p>2004年、David Heinemeier Hansson は <a href=https://en.wikipedia.org/wiki/Ruby_on_Rails>Ruby on Rails</a> を発表した。これは PofEAA で紹介されたパターンを使いやすく取り込んだ Web フレームワークである。</p><p>Dan Kegel が1999年に論じた <a href=http://www.kegel.com/c10k.html>C10K problem</a> はのちに有名になっていった。10000以上のクライアントが同時にアクセスしても耐えられるサーバはどうすれば作られるかという話である。Apache のように、クライアントごとに別々の OS スレッドで処理させるアーキテクチャでは、クライアントの同時アクセスが増えればスレッドも増えて、限界が生じる。特に、Ruby on Rails 以降、Web アプリケーション開発用言語として広く採用されるようになった Python や Ruby は、<a href=https://wiki.python.org/moin/GlobalInterpreterLock>グローバルインタープリタロック (GIL)</a> を持っていたり並行プログラミングが得意でなかったりして、スケールアウトさせることは難しかった。そんな中でメジャーになっていったのが、並行プログラミングまたは非同期プログラミングを得意とする Erlang、Node.js、Go である。</p><p>Erlang はスウェーデンの通信機器メーカーであるエリクソンで、Joe Armstrong らが開発したプログラミング言語だ。1986年に作られたらしいが、1998年にオープンソースとして公開された（<a href=https://www.labouseur.com/courses/erlang/history-of-erlang-armstrong.pdf>History of Erlang</a>）。Prolog の影響がある文法による関数型プログラミング言語で癖はあるが、それを超えて<a href=https://en.wikipedia.org/wiki/Actor_model>アクターモデル</a>をもとにしたパワフルな並行プログラミングを可能にする。Erlang のプロセスは軽量スレッドであり、非同期で任意のオブジェクトをメッセージとして送信したり受信したりできる。OS ネイティブスレッドと違って、Erlang のプロセスは驚くほど軽量なため、C10k problem への解決策になった。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-erlang data-lang=erlang><span style=display:flex><span><span style=color:#75715e>% Create a process and invoke the function web:start_server(Port, MaxConnections)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ServerProcess <span style=color:#f92672>=</span> spawn(web, start_server, [Port, MaxConnections]),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>% Send a message to ServerProcess (asynchronously).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>ServerProcess <span style=color:#f92672>!</span> {pause, <span style=color:#ae81ff>10</span>},
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>% Receive messages sent to this process.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>receive</span>
</span></span><span style=display:flex><span>    a_message <span style=color:#f92672>-&gt;</span> do_something;
</span></span><span style=display:flex><span>    {data, DataContent} <span style=color:#f92672>-&gt;</span> handle(DataContent);
</span></span><span style=display:flex><span>    {hello, Text} <span style=color:#f92672>-&gt;</span> io:<span style=color:#a6e22e>format</span>(<span style=color:#e6db74>&#34;Got hello message: </span><span style=color:#e6db74>~s</span><span style=color:#e6db74>&#34;</span>, [Text]);
</span></span><span style=display:flex><span>    {goodbye, Text} <span style=color:#f92672>-&gt;</span> io:<span style=color:#a6e22e>format</span>(<span style=color:#e6db74>&#34;Got goodbye message: </span><span style=color:#e6db74>~s</span><span style=color:#e6db74>&#34;</span>, [Text])
</span></span><span style=display:flex><span> <span style=color:#66d9ef>end</span>.
</span></span></code></pre></div><p>2009年に Ryan Dahl が公開した <a href=https://en.wikipedia.org/wiki/Node.js>Node.js</a> は、Google Chrome の高速な JavaScript エンジンである V8 をもとにした JavaScript 処理系で、libev/libuv ライブラリを使った非同期 I/O を実現している。Node.js 自体はほぼシングルスレッドで動くが、非同期プログラミングによって I/O 箇所はマルチスレッドのように動く（マルチスレッドのコストなしで）。興味深いことに、素直にスレッドプールでリクエストごとに別スレッドが処理を担当するような実装よりも、Node.js のようなシングルスレッドの非同期 I/O 処理の方が C10k problem への解決策になった。</p><p>2009年に公開された <a href=https://opensource.googleblog.com/2009/11/hey-ho-lets-go.html>Go</a> は、CSP をもとにした並行プログラミングを可能にする。軽量スレッドであるゴルーチンと、ゴルーチン間で値を送受信して通信するためのチャネルがある。Erlang のアクターモデルと比べると、プロセスにメールボックス（チャネル）が紐付いているのでなく、ゴルーチンとチャネルを明確に分けている点が違うが、おおよそ同じようなもので、C10k problem への解決策になった。</p><h1 id=web-application-architecture>Web Application Architecture</h1><h2 id=pofeaa-の-layered-architecture>PofEAA の Layered Architecture</h2><p>2002年、Martin Fowler は前述の技術書 PofEAA で Web アプリケーションのアーキテクチャについて論じた。第１章の「レイヤ化 (Layering)」では、Layered Architecture をこうまとめている：</p><ul><li>Presentation Layer: ユーザからの入力を扱って Domain Layer に実処理を任せたり、HTML ページなどの表示を行ったりする。</li><li>Domain Layer: ビジネスロジックを行う。Presentation Layer からユーザの入力を受け取って、バリデーションしたり、Data Source Layer とつなげて永続的なデータの操作をしたりして、Presentation Layer に表示用のデータを返す。</li><li>Data Source Layer: データベースや他のシステムと通信して、永続的なデータの操作などを行う。</li></ul><h2 id=alistair-cockburn-の-hexagonal-architecture>Alistair Cockburn の Hexagonal Architecture</h2><p>PofEAA では Alistair Cockburn の <a href=https://alistair.cockburn.us/hexagonal-architecture/>Hexagonal Architecture</a> も紹介している。Hexagonal Architecture というコンセプトが生まれた年は不明だが、<a href=https://silkandspinach.net/2004/07/13/hexagonal-architecture/>Kevin Rutherford</a> によれば1998年頃にはあったというらしい。ただ、その後も徐々にコンセプトを進化させていったんだとは思う。Hexagonal Architecture は対称的なアーキテクチャである：</p><ul><li>Adapter Layer: 外部からの入力を受け取って、Application Layer が扱える形式に変換して、Application Layer に引き渡す。また、Application Layer から出力を受け取って、外部システムが受け取れる形式に変換して、外部システムに引き渡す。デザインパターンの <a href=https://en.wikipedia.org/wiki/Adapter_pattern>Adapter パターン</a> にあたる。</li><li>Application Layer: Adapter Layer の内側にあり、ビジネスロジックを担う。</li></ul><h2 id=ddd-の-layered-architecture>DDD の Layered Architecture</h2><p>2003年、Eric Evans は技術書 <a href=https://www.domainlanguage.com/ddd/>Domain-Driven Design (DDD)</a> を出版した。ドメイン駆動設計という PofEAA の次に重要なコンセプトが論じられており、ここでの Layerd Architecture は PofEAA と少し異なる：</p><ul><li>User Interface Layer: PofEAA の Presentation Layer と同じ。</li><li>Application Layer: ドメインロジックを含まない、アプリケーションサービスを担う。アプリケーションサービスとドメインロジックの区別は少し難しいので、後に扱う。</li><li>Domain Layer: ドメインロジックを担う。PofEAA の Domain Layer は、DDD の Application Layer と Domain Layer を合わせたもの。</li><li>Infrastructure: PofEAA の Data Source Layer と同じ。</li></ul><p>PofEAA と DDD で共通しているのは、User Interface -> Application/Domain -> Infrastructure という層の依存関係である。ここで Application/Domain が Infrastructure に依存しているのは微妙だという批判がある。これに対して対称的な Hexagonal Architecture は、内側に Application Layer があって、外側に UI も Infrastructure もまとめた Adapter Layer があるため、 Application Layer は何にも依存しない。確かにこの方がクリーンだが、Application/Domain Layer はどうしても Data Source への操作を行わなければならないから、「依存の逆転」が必要になる。</p><h2 id=jeffrey-palermo-の-onion-architecture>Jeffrey Palermo の Onion Architecture</h2><p>2008年、DDD のような Layered Architecture に対して「依存の逆転」をすることで Hexagonal Architecture スタイルにしたのが、Jeffrey Palermo の <a href=https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/>Onion Architecture</a> だった：</p><ul><li>Domain Model Layer: ドメインモデルを担う。円状のレイヤーで、一番内側にある。</li><li>Domain Service Layer: ドメインサービスを担う。Domain Model Layer の１つ外側にある。</li><li>Application Service Layer: アプリケーションサービスを担う。Domain Service Layer の１つ外側にある。</li><li>UI/Infrastructure/Test Layer: DDD の UI Layer と Infrastructure Layer と同じ。一番外側にある。</li></ul><h2 id=robert-c-martin-の-clean-architecture>Robert C. Martin の Clean Architecture</h2><p>2012年、こうしたアーキテクチャをさらにまとめ直したのが、Robert C. Martin の <a href=https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html>Clean Architecture</a> だった：</p><ul><li>Entity Layer: DDD の Domain Layer と同じ。円状のレイヤーで、一番内側にある。</li><li>Use Case Layer: DDD の Application Layer と同じ。ただ DDD では Application Layer は薄くあるべきと言うが、Clean Architecture では必ずしもそうでない、ドメインサービス的なロジックがなかばここに吸収されることもある。Entity Layer の１つ外側にある。</li><li>Interface Adapter Layer: Hexagonal Architecture の Adapter Layer と同じ。外部インタフェース用から渡ってきたデータを、Use Case Layer / Entity Layer 用の形式に変換したり、その逆変換をして外部インタフェースに渡したりする。Use Case Layer の１つ外側にある。</li><li>Infrastracture Layer: Web フレームワークや DB そのもの。一番外側にある。</li></ul><h1 id=modern-web-application-frameworks>Modern Web Application Frameworks</h1><h2 id=ruby-on-railshttpsrubyonrailsorg><a href=https://rubyonrails.org/>Ruby on Rails</a></h2><ul><li>Good: 今でもメジャーな Ruby の Web アプリケーションフレームワーク。</li><li>Good: 洗練された使いやすい API を持つ。</li><li>Good: 長い歴史により、高機能と高安定性を備えている。</li><li>Good: プロジェクトのディレクトリ構成があらかじめ作られたり、様々な Conventions が定義されていたりするため、それに従って書くだけで、おおよそのレイヤードアーキテクチャとモジュラリティが保たれる。</li><li>Bad: ActiveRecord パターンが採用されているため、Domain Model と Repository パターンが１つのクラスに合わさっているような状態。その結果、Fat Model になりやすいという問題がある。もっと適当に書くと Fat Controller になりやすい。サービス層やフォームオブジェクト層は意識して作る必要がある。</li><li>Bad: Ruby なので、C10k 問題には厳しい。Ruby で強力な非同期 Web サーバが実装されればよいが、今はまだ <a href=https://github.com/puma/puma>puma</a> 全盛のようだ。</li><li>Bad: Ruby なので、メモリ消費や処理速度は期待できない。</li><li>Bad: Ruby on Rails によって一躍メジャーな言語になった Ruby だが、近年 Ruby は廃れ始めている。</li></ul><p><a href=https://hanamirb.org/>Hanami</a> は、Ruby on Rails を DDD/Hexagonal/Clean Architecture の考え方に寄せて洗練させようとした Ruby の Web アプリケーションフレームワークである。サービス層として <a href=https://guides.hanamirb.org/v1.3/architecture/interactors/>Interactor</a> を導入したり、コントローラの<a href=https://guides.hanamirb.org/v1.3/actions/overview/>アクションごとに１つのクラス</a>にしたり、<a href=https://guides.hanamirb.org/v1.3/repositories/overview/>Repository</a> パターンを導入したり。わたしは Hanami は結構好きなのだが、Ruby on Rails のコントローラや ActiveRecord がひどい欠点というわけでもないので、であればメジャーで高機能な Rails を使えばいいかなと思ってしまっている。</p><h2 id=fastapihttpsfastapitiangolocom><a href=https://fastapi.tiangolo.com/>FastAPI</a></h2><ul><li>Good: Python の Web アプリケーションフレームワークとしては、近年メジャーになっている。</li><li>Good: 後発のフレームワークだけあって、Python 言語や各種ライブラリの最新機能を活用して、洗練された使いやすい API を持つ。</li><li>Good: ASGI フレームワーク <a href=https://www.starlette.io/>Starlette</a> を利用して非同期 I/O を実現しているため、Python でありながらハイパフォーマンス。</li><li>Good: OpenAPI との親和性が高い。</li><li>Bad: 名前の通り、API サーバを作るためのフレームワークであって、HTML/CSS/JavaScript を操作するための便利な機能は備えていない。Jinja2 による HTML テンプレートを使うくらいなら簡単にできるが、それ以上は難しい。</li><li>Bad: Python なので、メモリ消費やロジック処理速度は期待できない。非同期 I/O によって HTTP リクエスト処理は高速だが、CPU-bound な処理はマルチコアを活用できない。</li><li>Bad: DB 操作は、任意の Python ライブラリに任せており、公式ドキュメントでは <a href=https://fastapi.tiangolo.com/tutorial/sql-databases/>SQLAlchemy の例</a> が書かれている。FastAPI との親和性は特にないので（親和性が悪いわけでもない）、注意を要する。</li><li>Bad: プロジェクトのディレクトリ構成もモジュール構造も名前も自由のため、適当に書くとレイヤーもモジュラリティもないコードになる。</li></ul><h2 id=echohttpsecholabstackcom><a href=https://echo.labstack.com/>Echo</a></h2><ul><li>Good: Go によるマイクロ Web アプリケーションフレームワークで、シンプルかつ一定の機能を備えている。</li><li>Good: Go なのでハイパフォーマンスで、メモリ消費も少ない。</li><li>Good: 同じ Go の Web アプリケーションフレームワークとしては <a href=https://gin-gonic.com/>Gin</a> があるが、Gin より後発なだけあって、API は少しだけ Gin より綺麗。</li><li>Bad: フルスタックでない Web アプリケーションフレームワークなので、機能は少ない。必要に応じてほかの Go ライブラリを選定して利用することになる。Echo 自体は悪くないライブラリだが、ほかの Go ライブラリの信頼性は不明なので、そこで罠にはまる可能性が高い。</li><li>Bad: DB 操作のライブラリは、そもそも Go であまりよいものがない。ORM の <a href=https://gorm.io/>GORM</a> は強力だが、まだ少しバギーなのと、あまり型安全でない。最近では <a href=https://entgo.io/>Ent</a> が型安全でよいが、まだ機能が足りておらず、やはりバギー。（バギーである証拠は、単純にわたしが普通に単純なアプリケーションを書いていて、どちらもバグに遭遇したこと）</li><li>Bad: パッケージ構成が自由なので、レイヤードアーキテクチャにするためにはかなり意識した設計を必要とする。</li><li>Bad: Go の Web アプリケーションすべてが遭遇する問題だが、ユニットテストを書くのが大変。</li></ul><h2 id=aspnet-corehttpsdocsmicrosoftcomen-usaspnetcoreviewaspnetcore-60><a href="https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-6.0">ASP.NET Core</a></h2><ul><li>Good: Microsoft による .NET 上で動く Web アプリケーションフレームワークで、ASP の後継である ASP.NET の後継。ASP、ASP.NET は基本的に Windows 上でしか動かなかったが（Mono を使うなどしなければ）、ASP.NET Core は クロスプラットフォームの .NET Core に合わせて作られたため、Linux や macOS 上でも動く。</li><li>Good: <a href=https://dotnet.microsoft.com/en-us/apps/aspnet/mvc>MVC</a>、<a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-6.0">Razor</a> テンプレート、バリデーション、Scaffolding、<a href=https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor>Blazor</a> による JavaScript なしでのインタラクティブ UI、<a href=https://dotnet.microsoft.com/en-us/apps/aspnet/signalr>SignalR</a> による WebSocket を使ったリアルタイムアプリ、<a href=https://docs.microsoft.com/en-us/ef/>Entity Framework</a> による DB 操作、<a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-6.0">Identity</a> による認証認可など、Ruby on Rails と同等以上の、世界トップクラスの高機能を提供している。</li><li>Good: .NET で動くため、ハイパフォーマンス。</li><li>Not Bad: .NET で動くライブラリのため、C# だけでなくほかの言語でも利用可能。ただ現実には、<code>dotnet new</code> でアプリケーションを作るとき多くのテンプレートや Scaffloding は C# しか選べない。C# 以外の言語で ASP.NET Core をやろうとしても恩恵が少ない。せっかく ASP.NET Core を採用するなら C# がよい。</li><li>Bad: .NET Core / ASP.NET Core はクロスプラットフォームだが、以前の ASP や .NET / ASP.NET は Windows 専用だった長い歴史もあり、非 Windows 環境上の .NET 利用についてはメジャーでない。</li><li>Bad: .NET と ASP.NET Core 特有の設計思想やツールチェイン上に作られているため、.NET 以外の好みが分かれる。</li><li>Bad: .NET と ASP.NET Core の学習曲線はかなり険しい。しかも UNIX 的な世界観に慣れていても役に立たない。</li></ul><p>参照: <a href=https://github.com/gothinkster/aspnetcore-realworld-example-app>https://github.com/gothinkster/aspnetcore-realworld-example-app</a>, <a href=https://github.com/ardalis/cleanarchitecture>https://github.com/ardalis/cleanarchitecture</a></p><h2 id=nesthttpsnestjscom><a href=https://nestjs.com/>Nest</a></h2><ul><li>Good: Node.js (TypeScript/JavaScript) の Web アプリケーションフレームワークで、実績ある <a href=https://expressjs.com/>Express</a> または <a href=https://www.fastify.io/>Fastify</a> 上で動く。</li><li>Good: <a href=https://angular.io/>Angular</a> の影響を受けたアプリケーションアーキテクチャでバックエンドアプリケーションが作られるように設計されており、自然とモジュラリティの高いコードになる。</li><li>Good: Node.js の強力な非同期 I/O によって、ハイパフォーマンスを実現している。V8 エンジンによってロジック処理速度も高速。</li><li>Bad: フルスタックでない Web アプリケーションフレームワークなので、フロントエンドや DB 操作は関わらない。現実には、好きなフロントエンドと DB 操作ライブラリ（今なら <a href=https://www.prisma.io/>Prisma</a> がいいか）を選んで学習・利用する必要がある。</li><li>Bad: Angular のアプリケーションアーキテクチャ思想に従っているが、これは独特なので好みが分かれる。前述したようなレイヤードアーキテクチャとはあまり合致しない。</li><li>Bad: 非同期 I/O なので高速だが、基本的にシングルスレッドなのでマルチコアを活用できず、パフォーマンスに限界がある。Requests/sec を測るシンプルなベンチマークでは高速だが、これは <a href=https://docs.microsoft.com/en-us/dotnet/standard/async-in-depth>CPU-bound でなく I/O-bound であれば非同期 I/O が十分に効果を発揮する</a>からであって、CPU-bound な処理を含むアプリケーションではマルチコアを活用したい。</li></ul><p>Nest の Angular-inspired アーキテクチャについては説明を要する。</p><ul><li>Controller <code>cats.controller.ts</code>: リクエストを受け付けて、レスポンスを返すオブジェクト。<code>@Controller('PATH')</code> デコレータを付けてクラスを宣言する。<ul><li>MVC の Controller そのもの。</li></ul></li><li>Provider <code>cats.service.ts</code>: 依存注入 (DI) 可能なオブジェクト。<code>@Injectable()</code> デコレータを付けてクラスを宣言する。<ul><li><code>@Injectable() class CatsService</code> を宣言しておけば、別クラスのコンストラクタ <code>constructor(private catsService: CatsService)</code> には自動で <code>CatsService</code> のインスタンスが渡されて依存注入される。<a href=https://docs.nestjs.com/providers>Providers | NestJS</a> 参照。</li></ul></li><li>Module <code>cats.module.ts</code>: モジュールとして機能をまとめあげる。<code>@Module({ controllers: [...], providers: [...], imports: [...], exports: [...] })</code> デコレータを付けてクラスを宣言する。<ul><li>モジュール <code>Cats</code> 内のプロバイダ <code>CatsService</code> は、(1) <code>Cats</code> から <code>CatsService</code> をエクスポートして、(2) 利用したい別モジュールから <code>Cats</code> をインポートしなければ、利用できない。</li></ul></li><li>Middleware <code>logger.middleware.ts</code>: Express のミドルウェアと同じもの。<code>@Injectable()</code> デコレータを付けて <code>NestMiddleware</code> インタフェースを実装してクラスを宣言する。</li><li>Exception Filter <code>http-exception.filter.ts</code>: 例外フィルタ。<code>ExceptionFilter</code> インタフェースを実装してクラスを宣言する。</li><li>Pipe <code>validation.pipe.ts</code>: パイプ。<code>@Injectable()</code> デコレータを付けて <code>PipeTransform</code> インタフェースを実装してクラスを宣言する。<ul><li>パイプは通常、コントローラの引数に対して <code>@Body()</code>, <code>@Query()</code>, <code>@Param()</code> のようなデコレータを付けることで、入力データの変換処理やバリデーション処理を行う。</li></ul></li><li>Guard <code>auth.guard.ts</code>: ガード。<code>@Injectable()</code> デコレータを付けて <code>CanActivate</code> インタフェースを実装してクラスを宣言する。<ul><li>ガードは通常、コントローラに対して <code>@UseGuards(AuthGuard)</code> のようにデコレータを付けることで、認証・認可のようなチェックを行う。</li></ul></li><li>Interceptor <code>logging.interceptor.ts</code>: アスペクト指向プログラミングのインターセプタ。<code>@Injectable()</code> デコレータを付けて <code>NestInterceptor</code> インタフェースを実装してクラスを宣言する。</li></ul><h2 id=blitzhttpsblitzjscom><a href=https://blitzjs.com/>Blitz</a></h2><ul><li>Good: Node.js (TypeScript/JavaScript) のフルスタック Web アプリケーションフレームワークで、Next.js や Prisma のような最新の強力なライブラリを採用している。</li><li>Good: Ruby on Rails の影響を受けており、（といっても Rails っぽいディレクトリ構成やアーキテクチャではないけれど）その思想に従って、使いやすい API やアーキテクチャを目指している。</li><li>Good: Node.js の強力な非同期 I/O によって、ハイパフォーマンスを実現している、と思われる。V8 エンジンによってロジック処理速度も高速。</li><li>Good: フロントエンドは Next.js なので、React によるシンプルで強力な UI コンポーネント操作ができるし、Next.js による SSG/SSR もできる。フロントエンドがどんどん進化していって、jQuery で DOM を触る牧歌的な時代は大昔に終わり、フロントエンドとバックエンドとのコードの親和性を維持することはできなくなった。しかし Blitz であれば、フロントエンドとバックエンドを１つの言語・フレームワークで記述してまとめ上げることができる。</li><li>Bad: まだ新しいフレームワークで、安定性は不明。</li><li>Bad: React, Next.js, Prisma（別の DB ライブラリを使えないわけではない）、フォームライブラリなどの知識を別に必要とするため、学習は意外と大変。また、それらの「巨人の肩」群を床に配置して Blitz という糸で結び付けただけといえばそうなので、全体の親和性は高くない。</li><li>Bad: 非同期 I/O は高速だが、<a href=https://blitzjs.com/docs/tradeoffs#single-threaded>シングルスレッド</a>なのでマルチコアを活用できず、パフォーマンスに限界がある。</li><li>Bad: <a href=https://blitzjs.com/docs/tradeoffs#advanced-backend-architecture>バックエンド部分</a>については機能が足りていない。詳しくは後述するが、Query/Mutation 関数で自動で作られる RPC API は公開を想定しているものでない。</li></ul><p>Blitz には、サーバ上のデータを取得する Query とサーバ上のデータを更新する Mutation というコンセプトがある。Query と Mutation は<a href=https://blitzjs.com/docs/query-resolvers>サーバ上で動く非同期 JavaScript 関数</a>で、クライアントサイドでの Query/Mutation の呼び出しは<a href=https://blitzjs.com/docs/client-and-server>自動で RPC（サーバ API）に置き換わる</a>し、<a href=https://blitzjs.com/docs/query-usage><code>useQuery</code></a>, <a href=https://blitzjs.com/docs/mutation-usage><code>useMutation</code></a> ごしに呼ぶことになっている。<a href=https://blitzjs.com/docs/rpc-specification>RPC 仕様</a>によれば、シンプルに、<code>POST /api/rpc/{関数名}</code> エンドポイントに対して JSON でパラメータを送ると JSON レスポンスが返ってくる形式になっている。<a href=https://blitzjs.com/docs/manifesto>Manifesto</a> の &ldquo;2 API Not Required&rdquo; にあるように、Blitz のユースケースは API 公開をほとんど想定していないため、REST API でも GraphAPI でもない独自の HTTP RPC API でもよいということなんだろう。</p><p>TypeScript/JavaScript で DB 操作を利用する場合、今では <a href=https://www.prisma.io/>Prisma</a> か <a href=https://typeorm.io/>TypeORM</a> がメジャーだと思う。TypeORM は Rails や Django のような ActiveRecord パターンであり、Fat Model 問題につながりやすく、Prisma の方がモダンであるとされるが、好みの差。Prisma を少しだけ触っただけだが、まだ新しいライブラリで、まだ安定性というか細かい部分の挙動制御が足りていないように思われた。が、具体的に何だったか忘れたから、間違いかもしれない。</p><h1 id=modern-requirements>Modern Requirements</h1><p>モダンな Web アプリケーションフレームワークの要件を考える。</p><h2 id=routing>Routing</h2><p><a href=https://echo.labstack.com/guide/routing/>Echo</a> は、URL パスとコントローラ関数とのマッピングを記述することで、ルーティングを定義する：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>postsList</span>(<span style=color:#a6e22e>c</span> <span style=color:#a6e22e>echo</span>.<span style=color:#a6e22e>Context</span>) <span style=color:#66d9ef>error</span> { <span style=color:#f92672>...</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>postsGet</span>(<span style=color:#a6e22e>c</span> <span style=color:#a6e22e>echo</span>.<span style=color:#a6e22e>Context</span>) <span style=color:#66d9ef>error</span> { <span style=color:#f92672>...</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>postsCreate</span>(<span style=color:#a6e22e>c</span> <span style=color:#a6e22e>echo</span>.<span style=color:#a6e22e>Context</span>) <span style=color:#66d9ef>error</span> { <span style=color:#f92672>...</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>echo</span>.<span style=color:#a6e22e>New</span>()
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>GET</span>(<span style=color:#e6db74>&#34;/posts&#34;</span>, <span style=color:#a6e22e>postsList</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>GET</span>(<span style=color:#e6db74>&#34;/posts/:id&#34;</span>, <span style=color:#a6e22e>postsGet</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>POST</span>(<span style=color:#e6db74>&#34;/posts&#34;</span>, <span style=color:#a6e22e>postsCreate</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><a href=https://guides.rubyonrails.org/routing.html>Ruby on Rails</a> は <code>config/routes.rb</code> という専用のファイルがあって、そこで URL パスとコントローラ・アクションとのマッピングを定義する。コントローラ・アクションは文字列で表現され、<code>admin/articles#index</code> は <code>Admin::ArticlesController#index</code> に対応する。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PostsController</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>list</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>show</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create</span>; <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>Rails</span><span style=color:#f92672>.</span>application<span style=color:#f92672>.</span>routes<span style=color:#f92672>.</span>draw <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  get <span style=color:#e6db74>&#39;posts&#39;</span>, <span style=color:#e6db74>to</span>: <span style=color:#e6db74>&#39;posts#index&#39;</span>
</span></span><span style=display:flex><span>  get <span style=color:#e6db74>&#39;posts/:id&#39;</span>, <span style=color:#e6db74>to</span>: <span style=color:#e6db74>&#39;posts#show&#39;</span>
</span></span><span style=display:flex><span>  post <span style=color:#e6db74>&#39;posts&#39;</span>, <span style=color:#e6db74>to</span>: <span style=color:#e6db74>&#39;posts#create&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p><a href="https://fastapi.tiangolo.com/tutorial/first-steps/?h=#step-3-create-a-path-operation">FastAPI</a> はコントローラ関数に対して URL パス情報を付与したデコレータを設定する。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>app <span style=color:#f92672>=</span> FastAPI()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app</span><span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;/posts&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>postsList</span>(): <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app</span><span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;/posts/</span><span style=color:#e6db74>{id}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>postsList</span>(id: str): <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@app</span><span style=color:#f92672>.</span>post(<span style=color:#e6db74>&#34;/posts&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>postsList</span>(): <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>ルータの効率的なアルゴリズムは、suffix tree またはその亜種が使われている。</p><h2 id=controller>Controller</h2><p>コントローラ層は、エンドポイントごとにコントローラ（アクション）関数を定義する。コントローラ関数は HTTP リクエストを受け付け、パラメータなどの情報を内側の層に渡して実処理を行わせて、その結果を使って HTTP レスポンスを返す。</p><p>コントローラ層は HTTP リクエストの様々な情報を取得できるが、その中でも Cookie の取得や IP アドレスの取得については使いやすい関数をフレームワークが用意する。</p><p>コントローラ層では、入力パラメータの変換処理を行う。たとえば JSON から構造体に変換するなどのバインディング処理がこれにあたる。一方で、バリデーション処理はコントローラでなくその内側の層でやるべきはず。</p><p>出力のテンプレート適用処理（ビュー層への処理の依頼）も、コントローラでなくその内側の層でやる。コントローラは、あくまで内側の層が作ったレスポンス情報を使って、それを HTTP レスポンスに設定するだけ。Cookie を設定するような処理も、内側からレスポンス情報の１つとして出力 Cookie（またはレスポンスヘッダ）を返すようにして、コントローラはその情報をもとに Cookie を設定するだけ。</p><h2 id=usecaseserviceinteractor>Usecase/Service/Interactor</h2><p>この層では、実際のリクエストに対する実処理を定義する。コントローラ層から、この層の実処理を呼ぶ。</p><h2 id=db-migration>DB Migration</h2><p><a href=https://guides.rubyonrails.org/active_record_migrations.html>Ruby on Rails の DB マイグレーション</a>は、(1) DB スキーマを Ruby の DSL コードで記述して、モデル層やリポジトリ層と別に管理する。(2) DB スキーマのコードはバージョンごとに新規ファイルで管理される。まずは <code>bin/rails generate migration CreateProducts</code> コマンドを実行すると <code>db/migrate/YYYYMMDDHHMMSS_create_products.rb</code> というファイルが生成されるので、それを書き換えて追加・更新したい DB スキーマを Ruby で記述する：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CreateProducts</span> <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>ActiveRecord</span><span style=color:#f92672>::</span><span style=color:#66d9ef>Migration</span><span style=color:#f92672>[</span><span style=color:#ae81ff>7</span><span style=color:#f92672>.</span><span style=color:#ae81ff>0</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>change</span>
</span></span><span style=display:flex><span>    create_table <span style=color:#e6db74>:products</span> <span style=color:#66d9ef>do</span> <span style=color:#f92672>|</span>t<span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>      t<span style=color:#f92672>.</span>string <span style=color:#e6db74>:name</span>, <span style=color:#e6db74>limit</span>: <span style=color:#ae81ff>255</span>, <span style=color:#e6db74>null</span>: <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>      t<span style=color:#f92672>.</span>text <span style=color:#e6db74>:description</span>, <span style=color:#e6db74>default</span>: <span style=color:#e6db74>&#39;&#39;</span>, <span style=color:#e6db74>null</span>: <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>      t<span style=color:#f92672>.</span>timestamps, <span style=color:#e6db74>null</span>: <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>これを本番リリース後、また DB スキーマを更新することになれば、既存のマイグレーションファイルはそのままで、新しいマイグレーションファイルを作る。Rails は暗黙に <code>schema_migrations</code> という DB テーブルを作っており、そこでどのマイグレーションファイルを実行ずみか記録している。<code>bin/rails db:migrate</code> コマンドで、まだ実行されていないマイグレーションファイルを実行して、DB マイグレーションを行う。<code>bin/rails db:rollback</code> コマンドはその逆で、ロールバックを行う。</p><p><a href=https://www.prisma.io/>Prisma</a> や <a href=https://entgo.io/>Ent</a> は、あらかじめスキーマ定義を DSL で記述しておいて、それをもとにライブラリが型安全な DB 操作インタフェースを提供してくれたり、DB マイグレーションを行ってくれたりする。Prisma は DB マイグレーション自体は行わず、DB マイグレーション用の SQL ファイルを生成する。</p><h2 id=repository--activerecord>Repository / ActiveRecord</h2><p>DB の操作は、Repository パターンまたは ActiveRecord パターンを通して行う。</p><h2 id=model>Model</h2><p>この層では、ドメインモデルを定義する。</p><h2 id=view>View</h2><p>ビュー機能、テンプレートを実装する。</p><ul><li>HTML や JSON データのレスポンス。</li><li>HTML テンプレートのレスポンス。</li><li>静的ファイルのレスポンス。</li></ul><h2 id=validation--form-object--request-object>Validation / Form Object / Request Object</h2><p>コントローラ層で受け取ったリクエストのパラメータは、バリデーションまたはフォームオブジェクト・リクエストオブジェクトといわれるクラスを通して、あらかじめバリデーションを行う。</p><h2 id=response-object>Response Object</h2><p>ユースケース層で実処理をしたあと、レスポンスオブジェクトといわれるクラスを通してレスポンス情報を返す。通常コントローラ層が、このレスポンスオブジェクトを適切な形式（JSON や HTML）に変換してレスポンスとして返す。</p><h2 id=session-management>Session Management</h2><p>セッション管理の実装についてはあまり語られることがない。プロダクションレディな高品質のセッション管理ライブラリは、実を言えば見たことがない。</p><ul><li>セッション情報を保存するデータストア（セッションストア）は、要件によって適切なものが異なるため、自由に選べることが望ましい。</li><li>リクエスト Cookie に含まれるセッションIDをもとにセッションストアからセッション情報を取得する。普通、同じリクエスト内では、最初にセッションストアから取得したらあとはメモリ上にキャッシュしておく。</li><li>新規セッションの場合、ランダムな新規セッションIDを発行する。</li><li>セッション情報を更新したら、すぐに、またはそのリクエスト処理の最後でまとめて、セッション情報をセッションストア上でも更新する。</li><li>セッション情報を永続データストアに保存するときは、なんらかのシリアライズの方法が必要となる。シリアライズの形式は、将来の実行言語処理系の変更を考えれば JSON や CBOR のようなポータブルな形式が望ましい。というより、シリアライズの形式を自由に選べるようなセッション管理ライブラリであることが望ましい。</li><li>Cookie にセッションIDをセットしてレスポンスを返す。</li><li>Cookie と、セッションストアに保存されたセッション情報については、セッションの有効期限を適切に設定する。</li><li>セッション固定攻撃への対策としてログイン前後ではセッションIDを変更する必要があるため、セッションIDを変更する機能が必要となる。</li><li>ログアウト時には、セッションを破棄する。</li></ul><p>シリアライズの形式まで考えられたセッション管理ライブラリはなかなかない。</p><h1 id=remote-ip-addresses>Remote IP Addresses</h1><p>どんな Web アプリケーションフレームワークや HTP サーバライブラリでも、クライアントの IP アドレスを取得する機能はある。ただ、その取得の仕方は単純でない。</p><ul><li>素直に IP アドレスを取得すると？<ul><li>直に Web アプリケーションがリクエストを受け付けている場合、問題ない。しかし、Web アプリケーションとクライアントの間にリバースプロキシなどを挟んでいる場合、素直にクライアント IP アドレスを取得するとそれはリバプロの IP アドレスになる。</li></ul></li><li>リバプロでなくクライアント IP アドレスを取得するために <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For><code>X-Forwarded-For</code> ヘッダ</a>などの値を使うと？<ul><li>ヘッダの中には、クライアント、クライアント側のプロキシ、サーバ側のリバプロといった複数の IP アドレスが格納されている。このとき、IP アドレスの配列の中で、どの値を使うべきか注意しないといけない。</li></ul></li><li>IP アドレスの取得を間違えると？<ul><li>Web アプリケーションが自前でクライアント IP アドレスを見て ACL をかけているような場合、クライアント IP アドレスを正しく取得できていないと脆弱性になりうる。</li></ul></li></ul><p>メジャーでないライブラリやミニマル志向のライブラリは、こういうところがケアされていない可能性が高い。メジャーなライブラリでも、過去に一度問題を踏んでから慌てて直している形跡がよく見られる。そのため、ライブラリを過信せず、利用者側も目を凝らしておくべき問題だと思う（そもそも、利用環境によって話が変わってくるので）。</p><p>IP アドレスの取得の仕方については、<a href=https://echo.labstack.com/guide/ip-address/>IP Address | Echo</a> の記事がよいか。</p><ul><li>Ruby on Rails<ul><li><a href=https://github.com/rails/rails/blob/main/actionpack/lib/action_dispatch/middleware/remote_ip.rb><code>ActionDispatch::RemoteIp</code></a> ミドルウェアで実装されている。コメントにも書かれている。2012年に IP アドレスの取得の仕方を間違えてしまって、2013年に<a href=https://github.com/rails/rails/pull/7980/files>直している</a>。</li></ul></li><li>Express<ul><li><a href=https://github.com/expressjs/express/issues/2099>2014年</a>に対応している。</li></ul></li><li>Echo<ul><li>比較的新しいフレームワークとはいえ、この問題に対応したのは、やっと<a href=https://github.com/labstack/echo/pull/1478>2020年</a>だった。</li></ul></li><li>Gin<ul><li>比較的新しいフレームワークとはいえ、この問題に対応したのは、後発の Echo よりも遅くやっと<a href=https://github.com/gin-gonic/gin/pull/2632>2021年</a>だった。</li></ul></li><li>FastAPI<ul><li>FastAPI 自体は扱っておらず、uvicorn などがこの問題を取り扱う。Trusted Hosts に対応したのは<a href=https://github.com/encode/uvicorn/pull/591>2021年</a>。ただ、<a href=https://github.com/encode/uvicorn/pull/144>それ以前の2018年</a>から、Trusted Hosts 関係なく <code>X-Forwarded-For</code> ヘッダの一番右の IP アドレスを使っていたから、問題の発生するケースはあったものの、一番左の IP アドレスを使うよりはまだましだったかと思う。</li></ul></li></ul><h2 id=mail>Mail</h2><p>一部の Web アプリケーションではメールの送信機能が必要になる。これは言語標準ライブラリの範囲でも通常なんとかなるが、Ruby on Rails の Action Mailer などではより便利な機能が付与されている。</p><h2 id=http-client>HTTP Client</h2><p>バックエンドの Web アプリケーション上で、連携している外部サービスの HTTP API をリクエストする必要があることがある。HTTP リクエストを送るだけなら言語標準ライブラリの範囲で問題ないが、リトライ機構は用意しなくてはならない。</p><h2 id=csrf-token>CSRF Token</h2><p>CSRF 対策に、CSRF トークンが必要となる。CSRF トークンはセッション管理が関連してくるため、セッション管理ライブラリと同レベルかそれ未満のライブラリしか存在しない。Ruby on Rails は CSRF トークンを自動で付与して自動でチェックしてくれるため、ほかのフレームワークより使いやすい。</p><h2 id=openapi>OpenAPI</h2><p>Web API は OpenAPI (Swagger) でドキュメント化することが望ましい。OpenAPI ライブラリは多くの言語にあるが、普通にエンドポイントを実装するだけで、そこから自動で OpenAPI ドキュメントを生成してくれる Web アプリケーションフレームワークは少ない（あるいは、あまり使い勝手がよくなくて、結局手動で OpenAPI ドキュメントを記述した方がよい）。例外は最初から OpenAPI との親和性を意識した FastAPI。</p><h2 id=encryption>Encryption</h2><ul><li>パスワードのハッシュ化。</li><li>データベースの特定カラムの暗号化。</li><li>Cookie に直接情報を保存するときの情報の暗号化。</li></ul><h2 id=i18n>I18n</h2><h2 id=websockets>WebSockets</h2></section></article><div class=column><div class="tags has-addons"><span class="tag is-dark">Created at</span>
<span class=tag><time datetime=2022-02-07T02:06:24+09:00>2022/02/07 02:06:24</time></span></div><div class="tags has-addons"><span class="tag is-dark">Tags</span>
<a href=/tags/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0 class="tag is-link">プログラミング</a></div></div></div></div></div><footer class=footer><div class="content has-text-centered"><p>Written by tn.</p><p>Generated by <a href=https://gohugo.io/>Hugo</a>.</p></div></footer></body></html>