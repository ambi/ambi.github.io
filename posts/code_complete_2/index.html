<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="cahies of tn: blog"><title>Steve McConnell『Code Complete 第２版』、読んだ - cahiers of tn</title><link type=text/css rel=stylesheet href=https://ambi.github.io/css/bulma.min.css><link type=text/css rel=stylesheet href=https://ambi.github.io/css/style.css></head><body><section class=container><nav class=navbar role=navigation aria-label="main navigation"><div class=navbar-brand><a class="navbar-item title" href=https://ambi.github.io/>cahiers of tn</a></div><div class=navbar-menu><div class=navbar-end><a class=navbar-item href=/posts/>Posts</a><a class=navbar-item href=/tags/>Tags</a></div></nav></section><hr><div id=main><div class=container><div class=columns><article class="column box is-8 content"><h1>Steve McConnell『Code Complete 第２版』、読んだ</h1><section class=mb-6><p>Steve McConnellの『Code Complete』（第２版、2004年）は、ソフトウェア開発の名著とされる。たとえば、<a href=https://dev.to/daolf/the-25-most-recommended-programming-books-of-all-time-5fel>The 25 most recommended programming books of all-time.</a>では第３位に位置している。わたしも昔読んだが、そのときは「よくまとまっているんだろうけれど、特に面白みがない本」という印象だった。ただし、そのときのわたしは遊びのプログラミングはしていたが、堅苦しいオフィスでのソフトウェア開発はしていなかった。</p><p>プラクティス本と呼べばいいんだろうか、プログラミング言語を限定せずにプログラミングの汎用的なグッドプラクティスを書いた類の本がある。『プログラミング作法』、『達人プログラマー』、『Clean Code』、『リーダブルコード』、『Code Complete』。近年ではプラクティス本はあまり流行らなくなった印象だが、言語ごとの強力な lint ツールが自動で助けてくれるからだろう。「『Code Complete』を読むこと。それに従って書くこと。レビュー時にそれに従っていないコードを指摘すること」そんな手間より「この lint ツールに従うこと。CI が勝手にエラーにするから」とする方が楽だ。</p><p>プラクティス本として見ると、『Code Complete』は一般的なグッドプラクティスを言っているだけなので、初読時と同じ感想で「特に面白みがない」。ただ、『Code Complete』のポイントは、類書と比べると少しアカデミックな堅苦しい書き方と、コーディングだけでなくソフトウェア開発全体にフォーカスしていることにある。</p><p>2022年に読み直してみたところ、まずすごい労作だと思う。特に第１版が出版された昔や、第２版が出版された当時は、名著とされるに足る。</p><p>ただ、現在となっては、本書の中心的な内容であるコーディングプラクティス部分はすすめづらい。言語中立の書き方で、しかも Visual Basic がサンプル言語の１つとして選ばれているため、利用している言語向けのプラクティス記事を読む方がよい。</p><p>『Code Complete』で書かれていることは、適切で大切なことだ。しかし、この本を読んで学べる人はすでにその内容を実践できている実力の人だし、逆にそうでない人はこの本を読んでも説明の具体性が足りなくて実践できない。1/5くらいの分量にして「詳細は参考文献を参照」を連発するか、C++ か C# にでも対象言語を絞って具体的な１つのプロジェクト開発の例を一貫して出して記述するか。どちらかにした方がよそうだ。</p><p>面白かったのは、参考文献。ここに Steve McConnell の個性が感じられた。</p><ul><li>Tom Gilb &ldquo;Principles of Software Engineering Management&rdquo; (1988)</li><li>Alain Abran et al. &ldquo;SWEBOK: Guide to the Software Engineering Body of Knowledge&rdquo; (2001)</li><li>Karl Wiegers &ldquo;Software Requirements&rdquo; (2003)</li><li>Len Bass, Paul Clements, Rick Kazman &ldquo;Software Architecture in Practice&rdquo; (2003)</li><li>Steve Maguire &ldquo;Writing Solid Code&rdquo; (1993)</li><li>Jon Bentley &ldquo;Programming Pearls&rdquo; (2000)</li><li>Andrew Hunt, David Thomas &ldquo;Prgamatic Programmer&rdquo; (2000)</li><li>KentBeck &ldquo;Extreme Programming Explained: Embrance Change&rdquo; (2000)</li><li>David L. Parnas &ldquo;On the Criteria to Be Used in Decomposing Systems into Modules&rdquo; (1972)</li><li>Erich Gamma et al. &ldquo;Design Patterns: Elements of Reusable Objet-Oriented Software&rdquo; (1995)</li><li>Arthur J. Riel &ldquo;Object-Oriented Design Heuristics&rdquo; (1996)</li><li>Bertrand Meyer &ldquo;Object-Oriented Software Construction&rdquo; (1997)</li><li>Martin Fowler &ldquo;Refactoring&rdquo; (1999)</li><li>Brooks &ldquo;The Mythical Man-Month&rdquo; (1995)</li><li>Gerald M. Weinberg &ldquo;The Psychology of Computer Programming&rdquo; (1998)</li><li>DeMarco, Lister &ldquo;Peopleware&rdquo; (1999)</li></ul><p>上はあげられている参考文献の一部にすぎないが、Tom Gilb &ldquo;Principles of Software Engineering Management&rdquo; と Arthur J. Riel &ldquo;Object-Oriented Design Heuristics&rdquo; への高評価は印象的だった。</p><p>McConnell の Construx 社では <a href=https://www.construx.com/professional-development-ladder/>The Professional Development Ladder</a> を出していて、そこではレベルに応じた書籍を紹介している。たとえば、<a href=https://scrapbox.io/nobuoka-pub/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%88%E3%81%AE%E3%82%AD%E3%83%A3%E3%83%AA%E3%82%A2%E3%83%91%E3%82%B9>ソフトウェアアーキテクトのキャリアパス</a>。</p><h1 id=読書メモ>読書メモ</h1><h2 id=第１章-ソフトウェアコンストラクションへようこそ>第１章 ソフトウェアコンストラクションへようこそ</h2><p>この章では、この本のテーマであるソフトウェアコンストラクションについて説明している。</p><p>ソフトウェア開発は次のプロセスからなるとして：</p><ul><li>課題定義</li><li>要求開発</li><li>コンストラクション計画</li><li>ソフトウェアアーキテクチャ（または概略設計）</li><li>詳細設計</li><li>コーディングとデバッグ</li><li>単体テスト</li><li>統合テスト（または結合テスト）</li><li>統合</li><li>システムテスト</li><li>保守</li></ul><p>そのうち、ソフトウェアコンストラクションは上のほとんどのプロセスを含んではいるものの、重きを置いているのは「作る」プロセスつまり「コーディングとデバッグ」だという。要するに、ソフトウェアコンストラクションという用語は、ソフトウェア開発の言い換えにすぎないんだろうけれど、よりコーディングにフォーカスしているニュアンスが入っている。</p><p>ただし、重きを置いていないだけで、コーディング以外もソフトウェアコンストラクションに含まれるから、『Code Complete』ではすべて扱ってはいる。このすべてを扱っているということが偉い。</p><p>根本的な疑問として、ソフトウェア開発のプロセスを上のように定義することがどこから来たか、正しいかは分からない。この章については参考資料がない。</p><h2 id=第２章-ソフトウェア開発への理解を含めるメタファ>第２章 ソフトウェア開発への理解を含めるメタファ</h2><p>この章ではメタファの説明をしている。</p><p>それ自体はプログラミングと関係ない「メタファ」というテーマだけで１章費やしているのは、本のバランスを崩していると思った。読者を「なんだこの本…？」と困惑させるだけじゃないか？　そもそも人間の思考活動にとってメタファは大事なので、ソフトウェア開発に限った話じゃない。</p><h2 id=第３章-２回測って１度で切る上流工程の必要性>第３章 ２回測って、１度で切る：上流工程の必要性</h2><p>この章では上流工程の説明をしている。</p><p>ソフトウェア開発の上流工程というのは、課題定義からソフトウェアアーキテクチャまでを指している。上流工程という準備が不足していると、手戻りのコストは最も高くなる。</p><h3 id=課題定義>課題定義</h3><p>「課題定義」は、プロジェクトビジョン、プロダクト定義などとも呼ばれる。ユーザの言葉で書かれた、システムが解決すべき課題。</p><h3 id=要求>要求</h3><p>「要求」は、要求開発、要求分析、ソフトウェア要求、仕様などとも呼ばれる。</p><p>要求仕様をどう書くかは具体例も何もないが、要求のチェックリストは用意されている。自分なりに簡潔化すると：</p><ul><li>機能要求<ul><li>システムへの入力を、入力元・精度・範囲・頻度を含めて明記する。</li><li>システムからの出力を、出力先・精度・範囲・頻度・出力形式を含めて明記する。</li><li>外部のハードウェアインタフェース、ソフトウェアインタフェース、通信インタフェースを明記する。</li><li>ユーザが実行したいと考えている各タスク、それ使われるデータを明記する。</li></ul></li><li>非機能（品質）要求<ul><li>ユーザが期待する応答時間を、操作ごとに期待する。</li><li>処理時間、データ転送の速度、システムのスループットなど、時間に関する検討事項を明記する。</li><li>セキュリティレベルを明記する。</li><li>ソフトウェアの障害の影響、障害から保護すべきデータ、エラーの検出と回復の手順を含め、信頼性を明記する。</li><li>最低限必要なメモリ容量と空きディスク容量を明記する。</li><li>特定機能の変更など、システムの保守性を明記する。</li></ul></li></ul><h3 id=アーキテクチャ>アーキテクチャ</h3><p>「アーキテクチャ」は、システムアーキテクチャ、概略設計とも呼ばれる。</p><p>アーキテクチャのチェックリストは用意されている：</p><ul><li>アーキテクチャの概要や理由付けを明記する。</li><li>プログラムのそれぞれの構成単位が受け持つ領域や、他の構成単位とのインタフェースを定義する。</li><li>主要なクラスの説明を明記する。</li><li>データ設計の説明、データベースの構造を明記する。</li><li>業務ルールを明記する。</li><li>ユーザインタフェースの設計方針を明記する。</li><li>入出力の処理方針を明記する。</li><li>リソースに対する使用量の見積もりやリソース管理の方針を明記する。</li><li>セキュリティ用件を明記する。</li><li>パフォーマンス目標の推定値と、機能のスペースと速度を見積もる。</li><li>スケーラビリティの実現方法を明記する。</li><li>相互運用性に対処する。</li><li>国際化と地域化の方針を明記する。</li><li>エラー処理方針を明記する。</li><li>フォールトトレランスの手法を定義する。</li><li>システムは技術的に実現可能か考慮する。</li><li>オーバーエンジニアリングへの取り組み方を明記する。</li><li>購入か構築かの決断を含める。</li><li>再利用するコードを説明する。</li><li>予想される変更に適応できる設計にする。</li><li>アーキテクチャの全体的な品質を確認する。</li></ul><h3 id=参考資料>参考資料</h3><p>最後に参考資料が紹介され、詳細はそちらに任せられている。この本だけでは上流工程の説明が圧倒的に足りないが、それはもう別の本で学べということなんだろうね。</p><p>要求・仕様については Karl E. Wiegers の『ソフトウェア要求』を読むべきなんだろうけど、紙版は絶版で、電子版も高い。『ユースケース実践ガイド』も読むべきなんだろうけれど、電子版はなく、紙版は絶版。高かったけど、中古で買った。あとは『SWEBOK』も紹介されている。</p><p>アーキテクチャの本はいろいろあるが、今だと『ソフトウェアアーキテクチャの基礎』なんだろうか。買ってないけれど。</p><p>ソフトウェア開発手法全般の本は、今はアジャイル系以外絶版しかない。</p><h2 id=第４章-コンストラクションの重要な決断>第４章 コンストラクションの重要な決断</h2><p>この章では、ソフトウェア開発をする上で選定すべきいくつかのものを説明している。プログラミング言語、プログラミング規約、ツールやフレームワークの選択について。</p><h2 id=第５章-コンストラクションにおける設計>第５章 コンストラクションにおける設計</h2><p>設計に望ましい特性：</p><ul><li>最小限の複雑さ</li><li>保守性：「保守プログラマを顧客と見なし、見ればすぐわかるようなシステムを設計しよう」</li><li>疎結合</li><li>拡張性</li><li>再利用性</li><li>高いファンイン：そのクラスを使用するクラスがたくさんあること。</li><li>高いファンアウト：１つのクラスが使用するほかのクラス数を少なくすること。</li><li>移植性</li><li>無駄のなさ</li><li>階層化：分解のレベルを階層化して、他のレベルを見なくても、１つのレベルを見ればわかるように設計する。</li><li>標準化手法</li></ul><p>設計のレベル：</p><ol><li>ソフトウェアシステム</li><li>サブシステムまたはパッケージへの分割<ol><li>業務ルール</li><li>ユーザインタフェース</li><li>データベースアクセス</li><li>システムへの依存部分</li></ol></li><li>クラスへの分割</li><li>ルーチンへの分割</li><li>ルーチンの内部設計</li></ol><p>構成要素の設計：</p><ul><li>現実世界のオブジェクトを見つけて、その属性・インタフェースを定義する</li><li>一貫した抽象化を行う</li><li>実装詳細をカプセル化する</li><li>（設計が単純になる場合）継承する</li><li>情報を隠蔽する</li><li>変更可能性が高い箇所を特定する（業務ルール、ハードウェアへの依存部分、入出力など）</li><li>疎結合を維持する</li><li>デザインパターンを探す</li></ul><p>参考資料では、情報隠蔽については David L. Parnas の３つの論文を「現時点で最も優れた資料である」として紹介している。<a href=https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf>&ldquo;On the Criteria to Be Used in Decomposing Systems into Modules&rdquo; (1972)</a>、<a href=https://courses.cs.washington.edu/courses/cse503/08wi/parnas-1979.pdf>&ldquo;Designing Software for Ease of Extension&rdquo; (1979)</a>、<a href=http://www.cse.msu.edu/~cse870/Input/SS2002/MiniProject/Sources/parnas84-mod-structure.pdf>&ldquo;The Modular Structure of Complex Systems&rdquo;(1985)</a>。</p><h2 id=第６章-クラスの作成>第６章 クラスの作成</h2><p>ADT、よいクラスの抽象化、よいクラスのカプセル化、継承の問題、クラスの利点について。『Effective C++』や『Effective Java』のようないわゆる Effective 本やプラクティス本で書かれているようなことが、言語中立的に詰め込まれている。</p><p>参考資料には Bertrand Mayer の &ldquo;Object-Oriented Software Construction&rdquo; が紹介されている。訳書が高い。</p><h2 id=第７章-高品質なルーチン>第７章 高品質なルーチン</h2><p>ルーチンの利点、ルーチンの凝集度、ルーチン名、ルーチンの長さ、ルーチンの引数、マクロとインラインルーチンについて。これも Effective 本やプラクティス本のような内容が詰め込まれている。</p><h2 id=第８章-防御的プログラミング>第８章 防御的プログラミング</h2><ul><li>無効な入力<ul><li>外部ソースからのデータの値をすべて確認する</li><li>ルーチンのすべての入力引数の値を確認する</li><li>不正な入力を処理する方法を決定する</li></ul></li><li>アサーション<ul><li>発生してはならい状況にアサーションを使う</li><li>事前条件と事後条件の文書と検証にアサーションを使う</li></ul></li><li>エラー処理<ul><li>当たり障りのない値を返す</li><li>次に有効なデータで代用する</li><li>全開と同じ答えを返す</li><li>有効な値のうち、最も近いもので代用する</li><li>ファイルに警告メッセージを記録する</li><li>エラーコードを返す</li><li>エラー処理ルーチン・オブジェクトを呼び出す</li><li>エラーが発生した場所でエラーメッセージを表示する</li><li>ローカルで最もうまくいく方法でエラーを処理する</li><li>処理を中止する</li></ul></li><li>例外<ul><li>無視すべきでないエラーに例外を使う</li><li>例外的な状況でのみ例外を使う</li><li>ライブラリコードが投げる例外を知る</li></ul></li><li>バリケードによるエラーの被害の囲い込み<ul><li>入力データは入力されたときに正しい型に変換する</li></ul></li></ul><h2 id=第９章-擬似コードによるプログラミング>第９章 擬似コードによるプログラミング</h2><p>ルーチンの詳細設計として擬似コードを書く、擬似コードプログラミングプロセス (PPP) について。PPP 以外の方法として、テスト駆動開発、リファクタリング、契約による設計を出している。</p><h2 id=第１０章-変数の使用>第１０章 変数の使用</h2><ul><li>変数は宣言時に初期化する。</li><li>変数のスコープは最小限に抑える。</li><li>変数の値は適切なタイミングでバインドする。</li><li>変数の目的は１つだけにする。</li></ul><h2 id=第１１章-変数名の力>第１１章 変数名の力</h2><p>変数や関数の名前の付け方について。</p><h2 id=第１２章-基本的なデータ型>第１２章 基本的なデータ型</h2><ul><li>数値<ul><li>0 による除算はエラーになる</li><li>異なる型の値の演算は、暗黙の型変換が行われる</li></ul></li><li>整数<ul><li>整数の除算は、端数が切り捨てられる</li><li>整数には最大値があるため、演算で桁あふれすることがある</li></ul></li><li>浮動小数点数<ul><li>浮動小数点数には有効桁数があるため、大きさが極端に異なる数同士の演算は情報落ちすることがある</li><li>浮動小数点数の演算では誤差が出るため、等価にならないことがある</li></ul></li></ul><h2 id=第１３章-特殊なデータ型>第１３章 特殊なデータ型</h2><p>構造体、ポインタ、グローバル変数について。</p><h2 id=第１４章-ストレートなコードの構成>第１４章 ストレートなコードの構成</h2><ul><li>ストレートなコードは、文の実行順序の依存性を明白にする。</li></ul><h2 id=第１５章-条件文の使用>第１５章 条件文の使用</h2><p>if/else, case 文について。</p><h2 id=第１６章-ループの制御>第１６章 ループの制御</h2><p>while, for 文について。</p><h2 id=第１７章-特殊な制御構造>第１７章 特殊な制御構造</h2><p>return, goto 文と再帰について。</p><h2 id=第１８章-テーブル駆動方式>第１８章 テーブル駆動方式</h2><p>テーブル駆動方式について。テーブル駆動方式について書かれた本はほかにもありそうだが、なんだろう。『プログラミング作法』にあったような気がしたんだけれど（Rob Pike はその後 Go で Table-Driven Testing を推進している）、手元に本がないので分からない。</p><h2 id=第１９章-制御構造の問題>第１９章 制御構造の問題</h2><ul><li>論理式は、肯定的な単純な式にして、かっこを使って明確化する</li><li>数値を含んでいる式は、数直線の順番に並べる</li><li>深いネストは減らす</li><li>構造化プログラミングは、制御構造を連続・選択・反復の３つとする</li></ul><h2 id=第２０章-ソフトウェアの品質>第２０章 ソフトウェアの品質</h2><p>品質保証について。</p><h2 id=第２１章-コラボレーティブコンストラクション>第２１章 コラボレーティブコンストラクション</h2><p>ペアプログラミング、ソフトウェアインスペクション（ピアレビュー）について。</p><h2 id=第２２章-デベロッパーテスト>第２２章 デベロッパーテスト</h2><ul><li>ルーチンの直線パスを 1 として、if/while 文 や case ごとや and/or 式があるたびに 1 を加える。その結果が最低限必要なテストケースの数となる。</li><li><code>defined -> used</code> データフローのすべてのパスをテストする。</li><li>過去に発生したよくあるエラーのテストケースを足す。</li><li>境界条件をテストする。</li><li>代表的な値をテストする。</li></ul><h2 id=第２３章-デバッグ>第２３章 デバッグ</h2><p>デバッグについて。</p><h2 id=第２４章-リファクタリング>第２４章 リファクタリング</h2><p>Martin Fowler の &ldquo;Refactoring&rdquo; をもとに、&ldquo;Code Complete&rdquo; では以下のリファクタリングを概略している：</p><ul><li>データレベルのリファクタリング<ul><li>マジックナンバーを名前付きの定数に置き換える</li><li>変数をより明白なものに変える</li><li>式をインラインにする</li><li>式をルーチンに置き換える</li><li>中間変数を導入する</li><li>多目的変数を複数の単一目的変数に変換する</li><li>ローカルの目的には引数ではなくローカル変数を使用する</li><li>データプリミティブをクラスに変換する</li><li>一連の型コードをクラスまたは列挙に変換する</li><li>一連の型コードをスーパークラスとサブクラスに変換する</li><li>配列をオブジェクトに変換する</li><li>コレクションをカプセル化する</li><li>従来のレコードをデータクラスに置き換える</li></ul></li><li>ステートメントレベルのリファクタリング<ul><li>論理式を分解する</li><li>複雑な論理式を分かりやすい名前の付いた論理関数にする</li><li>条件文に分散している重複するコードを１つにまとめる</li><li>ループ制御変数ではなく <code>break</code> や <code>return</code> を使用する</li><li>ネストした <code>if-then-else</code> ブロクで答えが分かったら、戻り値を代入せずに、すぐに <code>return</code> する</li><li>条件文、特に <code>case</code> 文の繰り返しをポリモーフィズムで書き換える</li><li><code>nukll</code> 値を評価するのではなく <code>null</code> オブジェクトを生成して使用する</li></ul></li><li>ルーチンレベルのリファクタリング<ul><li>ルーチンやメソッドを抽出する</li><li>ルーチンのコードをインラインにする</li><li>長いルーチンをクラスに変換する</li><li>複雑なアルゴリズムを単純な雨後リズムで代用する</li><li>引数を追加する</li><li>引数を削除する</li><li>問い合わせと更新を分離する</li><li>同じようなルーチンは引数を介在させてまとめる</li><li>入力引数によってふるまいに異なるルーチンを分離する</li><li>特定のフィールドではなくオブジェクト全体を渡す</li><li>オブジェクト全体ではなく特定のフィールドを渡す</li><li>ダウンキャストをカプセル化する</li></ul></li><li>クラス実装のリファクタリング<ul><li>値オブジェクトを参照オブジェクトに変更する</li><li>参照オブジェクトを値オブジェクトに変更する</li><li><code>virtual</code> メソッドをデータの初期化に置き換える</li><li>メソッドまたはメンバデータの配置を変更する</li><li>特殊なコードをサブクラスとして抽出する</li><li>同じようなコードをスーパークラスにまとめる</li></ul></li><li>クラスインタフェースのリファクタリング<ul><li>メソッドを別のクラスに移動する</li><li>１つのクラスを２つに分ける</li><li>クラスを削除する</li><li>委譲を隠蔽する</li><li>中間オブジェクトを削除する</li><li>継承を委譲に置き換える</li><li>委譲を継承に置き換える</li><li>外部ルーチンを導入する</li><li>拡張クラスを導入する</li><li>公開されているメンバ変数をカプセル化する</li><li>変更できないフィールドのセッタ・メソッドを削除する</li><li>クラスの外側で使用されないメソッドを隠蔽する</li><li>使用されないメソッドをカプセル化する</li><li>スーパークラスとサブクラスの自走が非常によく似ている場合は１つにまとめる</li></ul></li><li>システムレベルのリファクタリング<ul><li>制御できないデータについては、最も信頼のおけるデータソースを作成する</li><li>一方向のクラス結合を双方向のクラス結合に変更する</li><li>双方向のクラス結合を一方向のクラス結合に変更する</li><li>単純な雨後コンストラクタではなくファクトリメソッドを提供する</li><li>エラーコードを例外に置き換える、または例外をエラーコードに置き換える</li></ul></li></ul><h2 id=第２５章-コードチューニング戦略>第２５章 コードチューニング戦略</h2><p>コードチューニング戦略について。</p><h2 id=第２６章-コードチューニングテクニック>第２６章 コードチューニングテクニック</h2><p>コードチューニングテクニックについて。</p><h2 id=第２７章-プログラムサイズが及ぼす影響>第２７章 プログラムサイズが及ぼす影響</h2><p>プロジェクトが大きいほど、コミュニケーションコストが高くなり、生産性は下がる。プログラムサイズがフェうrほどエラー数は増える。</p><h2 id=第２８章-コンストラクションの管理>第２８章 コンストラクションの管理</h2><p>コーディングプラクティス、変更管理、工数の見積もり、ピープルウェアについて。</p><h2 id=第２９章-統合>第２９章 統合</h2><p>インクリメンタルなインテグレーションと、デイリービルドとスモークテストの自動化について。</p><h2 id=第３０章-プログラミングツール>第３０章 プログラミングツール</h2><p>CASE ツール、IDE、一括検索・置換、diff、フォーマッタ、スニペット、linter、リファクタリングツール、バージョン管理ツール、ビルドツール、デバッガ、テストルールなど。</p><h2 id=第３１章-レイアウトとスタイル>第３１章 レイアウトとスタイル</h2><p>コードのインデントのレイアウトについて。</p><h2 id=第３２章-読めばわかるコード>第３２章 読めばわかるコード</h2><p>コードコメントについて。</p><h2 id=第３３章-個人の資質>第３３章 個人の資質</h2><p>必要な個人の資質は、謙虚さ、好奇心、知的な誠実さ、創造性と規律、啓発的な怠惰。</p><h2 id=第３４章-ソフトウェア職人気質とは>第３４章 ソフトウェア職人気質とは</h2><h2 id=第３５章-さらに情報を得るには>第３５章 さらに情報を得るには</h2><p>様々な参考文献。</p></section></article><div class=column><div class="tags has-addons"><span class="tag is-dark">Created at</span>
<span class=tag><time datetime=2022-07-23T17:56:42+09:00>2022/07/23 17:56:42</time></span></div><div class="tags has-addons"><span class="tag is-dark">Tags</span>
<a href=/tags/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0 class="tag is-link">プログラミング</a></div></div></div></div></div><footer class=footer><div class="content has-text-centered"><p>Written by tn.</p><p>Generated by <a href=https://gohugo.io/>Hugo</a>.</p></div></footer></body></html>